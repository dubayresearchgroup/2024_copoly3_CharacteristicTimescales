import itertools
import random
import math
import sys
import collections
import numpy as np


def genseq(nmono=1, chainlength=1, pattern='homo', pXX=0.5):
    '''return sequences of A and B monomers.
    pattern can be "homo", "co", "alte", "block", "stat", "rand". '''
    nchain = nmono // chainlength
    if pattern == 'homo':
        return ['A' * chainlength] * nchain
    elif pattern == 'co':
        nchain_a = nchain // 2
        nchain_b = nchain - nchain_a
        return ['A' * chainlength] * nchain_a + ['B' * chainlength] * nchain_b
    elif pattern == 'alte':
        mono = itertools.cycle('AB')
        return [''.join([next(mono) for _ in range(chainlength)]) for _ in range(nchain)]
    elif pattern == 'block':
        nchain_1 = nchain // 2
        nchain_2 = nchain - nchain_1
        l1 = chainlength // 2
        l2 = chainlength - l1
        return ['A'*l1+'B'*l2]*nchain_1 + ['A'*l2+'B'*l1]*nchain_2
    elif pattern == 'stat':
        mono_a = nmono // 2
        mono_b = nmono - mono_a
        pool = ['A'] * mono_a + ['B'] * mono_b
        random.shuffle(pool)
        mono = itertools.chain.from_iterable(pool)
        return [''.join([next(mono) for _ in range(chainlength)]) for _ in range(nchain)]
    elif pattern == 'rand':
        def genbiased():
            '''used to generate a biased AA/AB/BB pair selectivity.'''
            mono_a = nmono // 2
            mono_b = nmono - mono_a
            num = {'A': mono_a, 'B': mono_b}
            pocket = []
            prev = 'A'
            pAB = 1 - pXX
            while num['A'] + num['B'] > 0:
                pA, pB = (pXX, pAB) if prev == 'A' else (pAB, pXX)
                now = 'A' if random.random() < (num['A'] * pA) / (num['A'] * pA + num['B'] * pB) else 'B'
                pocket.append(now)
                num[now] -= 1
                prev = now
            yield from pocket
        mono = genbiased()
        return [''.join([next(mono) for _ in range(chainlength)]) for _ in range(nchain)]
    else:
        return []


class System:
    itemlist = {}
    itemcounter = {}
    atom_map = {
        'A': 2, 
        'B': 3, 
        'link': 1
    }
    bond_map = {
        'A': 2,
        'B': 3,
        'link': 1
    }
    angle_map = {
        'A': 2,
        'B': 3,
        'link': 1
    }
    mono_bond_length = {
        'A': 0.4,
        'B': 0.4
    }
    connect_bond_length = 0.15
    bond_cutoff = 0.2

    def __init__(self, boxsize):
        for item in ['atom', 'bond', 'angle']:
            self.itemlist[item] = []
            self.itemcounter[item] = itertools.count(start=1)
        self.boxsize = boxsize

    def newitem(self, item, body):
        '''item in ['atom', 'bond', 'angle']
        body is a dict including properties.'''
        itemid = next(self.itemcounter[item])
        body['id'] = itemid
        self.itemlist[item].append(body)
        return itemid

    def itemsection(self, item):
        sec_name = {
            'atom': 'Atoms',
            'bond': 'Bonds',
            'angle': 'Angles'
        }
        out = f"{sec_name[item]}\n\n"
        fmt = {
            'atom': lambda atom: f"{atom['id']} {atom['mid']} {atom['type']} {atom['pos'][0]:g} {atom['pos'][1]:g} {atom['pos'][2]:g}\n",
            'bond': lambda bond: f"{bond['id']} {bond['type']} {bond['atoms'][0]} {bond['atoms'][1]}\n",
            'angle': lambda angle: f"{angle['id']} {angle['type']} {angle['atoms'][0]} {angle['atoms'][1]} {angle['atoms'][2]}\n"
        }
        for i in self.itemlist[item]:
            out += fmt[item](i)
        out += '\n'
        return out

    def head(self):
        return f'''Generated by dataPrep.py

{len(self.itemlist['atom'])} atoms
{len(self.atom_map)} atom types
{len(self.itemlist['bond'])} bonds
{len(self.bond_map)} bond types
{len(self.itemlist['angle'])} angles
{len(self.angle_map)} angle types
2 extra bond per atom
1 extra angle per atom
12 extra special per atom

0 {self.boxsize} xlo xhi
0 {self.boxsize} ylo yhi
0 {self.boxsize} zlo zhi

'''

    def makemonomer(self, monotype, center):
        bond_length = self.mono_bond_length[monotype]
        mono = [
            self.newitem('atom', {
                'mid': 0,
                'type': self.atom_map['link'],
                'pos': center + np.array([0, 0, -bond_length])
            }),
            self.newitem('atom', {
                'mid': 0,
                'type': self.atom_map[monotype],
                'pos': center.copy()
            }),
            self.newitem('atom', {
                'mid': 0,
                'type': self.atom_map['link'],
                'pos': center + np.array([0, 0, bond_length])
            })
        ]
        self.newitem('bond', {
            'type': self.bond_map[monotype],
            'atoms': [mono[0], mono[1]]
        })
        self.newitem('bond', {
            'type': self.bond_map[monotype],
            'atoms': [mono[1], mono[2]]
        })
        self.newitem('angle', {
            'type': self.angle_map[monotype],
            'atoms': mono
        })
        return mono

    def connect(self, mono1, mono2):
        '''1-2-3 + 4-5-6 => 1-2-3-4-5-6 
        monomers are group of 3 atom ids.'''
        self.newitem('bond', {
            'type': self.bond_map['link'],
            'atoms': [mono1[2], mono2[0]]
        })
        self.newitem('angle', {
            'type': self.bond_map['link'],
            'atoms': [mono1[1], mono1[2], mono2[0]]
        })
        self.newitem('angle', {
            'type': self.bond_map['link'],
            'atoms': [mono1[2], mono2[0], mono2[1]]
        })

    def calclength(self, chain):
        return sum(map(lambda mono: self.mono_bond_length[mono]*2, chain)) + (len(chain)-1)*self.connect_bond_length + self.bond_cutoff

    def length2bins(self, length, binsize):
        return math.ceil(length / binsize)

    def groupchainbylength(self, chains):
        '''return {length: [chains]} '''
        chainlengths = collections.defaultdict(list)
        for chain in chains:
            chainlengths[self.calclength(chain)].append(chain)
        return chainlengths

    def calcgrid(self, chains):
        '''decide what the number n to be to make a n*n*n grid.'''
        nmono = sum(map(len, chains))
        n_low = math.ceil(len(chains)**(1/3))
        n_high = int(self.boxsize // max(map(lambda mono: self.mono_bond_length[mono]*2+self.connect_bond_length, ['A', 'B'])))
        chainlengths = self.groupchainbylength(chains)
        # {number of grid points occupied: counts of those chains}
        for n in range(n_low, n_high+1):
            sizecounter = {self.length2bins(i, self.boxsize/n): len(j) for i, j in chainlengths.items()}
            sizevalues = list(sizecounter.keys())
            sizevalues.sort(reverse=True)
            if sizevalues[0] > n:
                continue
            placing = []
            for _ in range(n*n):
                column = []
                space = n
                cont = True
                while cont:
                    if len(sizevalues) == 0:
                        break
                    for i in sizevalues:
                        if i <= space:
                            column.append(i)
                            sizecounter[i] -= 1
                            if sizecounter[i] <= 0:
                                sizevalues.remove(i)
                            space -= i
                            cont = True
                            break
                        cont = False
                placing.append(column)
            if len(sizevalues) == 0:
                return n, placing
        raise Exception("Too many monomers to generate a configuration.")

    def seqongrid(self, chains):
        n, placing = self.calcgrid(chains)
        chainongrid = collections.defaultdict(list)
        for i in chains:
            chainongrid[self.length2bins(self.calclength(i), self.boxsize/n)].append(i)
        random.shuffle(placing)
        return n, [[chainongrid[i].pop() for i in column] for column in placing]

    def place_one_chain(self, chain, base_in):
        base = base_in.copy()
        base[2] += self.bond_cutoff / 2
        prev = None
        for mono in chain:
            base += np.array([0, 0, self.mono_bond_length[mono]])
            curr = self.makemonomer(mono, base)
            if prev is not None:
                self.connect(prev, curr)
            base += np.array([0, 0, self.mono_bond_length[mono]+self.connect_bond_length])
            prev = curr


    def makeconf(self, chains):
        n, chaincolumns = self.seqongrid(chains)
        binsize = self.boxsize / n
        offset_origin = np.array([binsize/2, binsize/2, 0])
        for xgrid in range(n):
            for ygrid in range(n):
                base = np.array([xgrid*binsize, ygrid*binsize, 0]) + offset_origin
                column = chaincolumns[xgrid+ygrid*n]
                for i in column:
                    self.place_one_chain(i, base)
                    base += np.array([0, 0, binsize*self.length2bins(self.calclength(i), self.boxsize/n)])

    def print(self):
        return self.head()+''.join(map(lambda item: self.itemsection(item), ['atom', 'bond', 'angle']))

def makesystem(seqlist, boxsize, **kwarg):
    system = System(boxsize)
    for i, j in kwarg.items():
        system.__setattr__(i, j)
    system.makeconf(seqlist)
    return system.print()

def from_monomer(filename, boxsize, nmono):
    '''nmono: total number of monomers, half will be A, half will be B.'''
    txt = makesystem(genseq(nmono, pattern='stat'), boxsize)
    with open(filename, 'w') as fp:
        fp.write(txt)

def from_oligomer(filename, boxsize, nmono=1, chainlength=1, pattern='homo', pXX=0.5):
    txt = makesystem(genseq(nmono, chainlength, pattern, pXX), boxsize)
    with open(filename, 'w') as fp:
        fp.write(txt)

if __name__ == "__main__":
    usage = '''gen_data filename mode args... 
    mode:
        mono: boxsize, nmono
        oligo: boxsize, nmono, chainlength, pattern, [pXX]
    '''
    if len(sys.argv) < 3:
        print(usage)
    elif sys.argv[2] not in {'mono', 'oligo'}:
        print(usage)
    elif sys.argv[2] == 'mono':
        if len(sys.argv) < 4:
            print(usage)
        else:
            from_monomer(sys.argv[1], float(sys.argv[3]), int(sys.argv[4]))
    else:
        if len(sys.argv) < 7:
            print(usage)
        else:
            from_oligomer(sys.argv[1], *[func(x) for func, x in zip([float, int, int, str, float], sys.argv[:8][3:])])