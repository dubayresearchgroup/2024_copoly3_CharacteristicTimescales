import io
import numpy as np

rdf_step = 20000000
BOX_SIZE = 50

def fetch(name, step, dest_name):
    with open(dest_name, 'w') as fp:
        fp.write(bi_fetch(name, step))

#%%
def bi_fetch(name, step, counts=1):
    with open(name, 'rb') as fp:
        #mm = mmap.mmap(fp.fileno(), 0)
        def get_ps(c):
            i = c
            step = None
            fp.seek(i)
            while True:
                line = fp.readline()
                if line.startswith(b'ITEM: TIMESTEP'):
                    break
                if line == b'':
                    break
                i = fp.tell()
            if line != b'':
                secondln = fp.readline()
                step = int(secondln)
            return i, step
        size = fp.seek(0, io.SEEK_END)
        left = 0
        left_step = get_ps(0)[1]
        left2, left2_step = get_ps(1)
        right, right_step = get_ps(size)
        pos = None
        while True:
            m = (left + right) // 2
            m, m_step = get_ps(m)
            #print(left_step, right_step)
            if step <= left_step:
                pos = left 
                break
            if step <= left2_step:
                pos = left2
                break
            if step == right_step:
                pos = right
                break
            if step <= m_step:
                #right, right_step = get_ps(m)
                right = m
                right_step = m_step
                left = left2
                left_step = left2_step
            else:
                #left, left_step = get_ps(m)
                left = m
                left_step = m_step
            left2, left2_step = get_ps(left+1)
                
            if right <= left2 and left2 < step:
                break
        if pos is None:
            return ''
        else:
            fp.seek(pos)
            txt = fp.readline()
            n = counts
            while n > 0:
                line = fp.readline()
                if line == b'':
                    break
                if line.startswith(b'ITEM: TIMESTEP'):
                    n -= 1
                txt += line
            return txt.decode()

def gettraj(filename):
    name = filename + "_end.lammpstrj"
    res = np.genfromtxt(name, skip_header=9)
    id2type = {}
    id2pos = {}
    for line in res:
        id = int(line[0])
        id2type[id] = int(line[1])
        id2pos[id] = line[2:] * BOX_SIZE
    return id2pos, id2type

def getbond1(filename):
    name = filename + "-bond_end"
    res = np.genfromtxt(name, skip_header=9, dtype=int)
    return res

def getbond2(rawbondls, id2type):
    #type 2 bond is original, type 1 is generated by reaction
    #return set of center atom pairs that bond. id from small to large.
    link2center = {}
    bond1ls = []
    for line in rawbondls:
        if line[0] != 1:
            atom1, atom2 = line[1:3]
            if id2type[atom1] != 1:
                atom1, atom2 = atom2, atom1
            # now atom1 is type 1.
            link2center[atom1] = atom2
        else:
            bond1ls.append(line[1:3])
    return set([(link2center[bond[0]], link2center[bond[1]]) for bond in bond1ls])

def calcgr(rls, cutoff, bin, rho):
    # given an r list, return g(r) histogram
    # return bin's x on the right edge, and rdf bins.
    x = np.arange(0, cutoff+bin, bin)
    y, _ = np.histogram(rls, x)
    d = (lambda r: rho * 4 / 3 * np.pi * (r**3 - (r-bin)**3))(x[1:])
    return x[1:], (y/d)


class Bins:
    def __init__(self, cutoff):
        self.cutoff = cutoff
        self.numbin = int(BOX_SIZE // cutoff)
        self.bins = {}
        self.monocount = 0
        self.monoAcount = 0
        self.monoBcount = 0
        #print(self.numbin)

    def pos2bin(self, pos):
        return tuple((pos // self.numbin).astype(int))

    def make(self, id2pos, id2type):
        # put atoms into bins, only containing center atoms (type 2 and 3)
        self.bins = {}
        self.monocount = 0
        for atom, pos in id2pos.items():
            if id2type[atom] == 1:
                continue
            if id2type[atom] == 2:
                self.monoAcount += 1
            if id2type[atom] == 3:
                self.monoBcount += 1
            self.monocount += 1
            bin = self.pos2bin(pos)
            if bin not in self.bins:
                self.bins[bin] = {atom: pos}
            else:
                self.bins[bin][atom] = pos

    def getatoms(self, bin):
        # return atom - pos pairs.
        if bin not in self.bins:
            return {}
        return self.bins[bin]

    def getneigh2(self, bin):
        q, r = np.divmod(bin, self.numbin)
        return tuple(r), q

    def getneigh(self, bin):
        # return a list of bin and the image.
        # bin is tuple type, image is np array.
        ozmo = (1, 0, -1)
        return [self.getneigh2(np.array(bin) + np.array([i, j, k])) for i in ozmo for j in ozmo for k in ozmo]

def rdf(filename):
    id2pos, id2type = gettraj(filename)
    bondpairs = getbond2(getbond1(filename), id2type)
    cutoff = 2.5
    bin_width = 0.05
    bins = Bins(cutoff)
    bins.make(id2pos, id2type)
    rls = []
    for bin in bins.bins:
        neighatoms = {}
        for neighbin, image in bins.getneigh(bin):
            for atom, pos in bins.getatoms(neighbin).items():
                neighatoms[atom] = pos + image * BOX_SIZE
        for atom1, pos1 in bins.getatoms(bin).items():
            for atom2, pos2 in neighatoms.items():
                if (atom1, atom2) in bondpairs or (atom2, atom1) in bondpairs or atom1 == atom2:
                    continue
                rls.append((lambda d: np.sqrt(np.sum(d*d)))(pos1 - pos2))
    x, y = calcgr(rls, cutoff, bin_width, bins.monocount/(BOX_SIZE**3))
    return x, (y / bins.monocount)



def rdf_pairAA(filename):
    id2pos, id2type = gettraj(filename)
    bondpairs = getbond2(getbond1(filename), id2type)
    cutoff = 2.5
    bin_width = 0.05
    bins = Bins(cutoff)
    bins.make(id2pos, id2type)
    rls = []
    for bin in bins.bins:
        neighatoms = {}
        for neighbin, image in bins.getneigh(bin):
            for atom, pos in bins.getatoms(neighbin).items():
                neighatoms[atom] = pos + image * BOX_SIZE
        for atom1, pos1 in bins.getatoms(bin).items():
            for atom2, pos2 in neighatoms.items():
                if (atom1, atom2) in bondpairs or (atom2, atom1) in bondpairs or atom1 == atom2:
                    continue
                elif id2type[atom1] != 2 or id2type[atom1] != id2type[atom2]:
                    continue
                rls.append((lambda d: np.sqrt(np.sum(d*d)))(pos1 - pos2))
    x, y = calcgr(rls, cutoff, bin_width, bins.monoAcount/(BOX_SIZE**3))
    return x, (y / (bins.monoAcount))

def rdf_pairBB(filename):
    id2pos, id2type = gettraj(filename)
    bondpairs = getbond2(getbond1(filename), id2type)
    cutoff = 2.5
    bin_width = 0.05
    bins = Bins(cutoff)
    bins.make(id2pos, id2type)
    rls = []
    for bin in bins.bins:
        neighatoms = {}
        for neighbin, image in bins.getneigh(bin):
            for atom, pos in bins.getatoms(neighbin).items():
                neighatoms[atom] = pos + image * BOX_SIZE
        for atom1, pos1 in bins.getatoms(bin).items():
            for atom2, pos2 in neighatoms.items():
                if (atom1, atom2) in bondpairs or (atom2, atom1) in bondpairs or atom1 == atom2:
                    continue
                elif id2type[atom1] != 3 or id2type[atom1] != id2type[atom2]:
                    continue
                rls.append((lambda d: np.sqrt(np.sum(d*d)))(pos1 - pos2))
    x, y = calcgr(rls, cutoff, bin_width, bins.monoBcount/(BOX_SIZE**3))
    return x, (y / (bins.monoBcount))


def rdf_pairAB(filename):
    id2pos, id2type = gettraj(filename)
    bondpairs = getbond2(getbond1(filename), id2type)
    cutoff = 2.5
    bin_width = 0.05
    bins = Bins(cutoff)
    bins.make(id2pos, id2type)
    rls = []
    for bin in bins.bins:
        neighatoms = {}
        for neighbin, image in bins.getneigh(bin):
            for atom, pos in bins.getatoms(neighbin).items():
                neighatoms[atom] = pos + image * BOX_SIZE
        for atom1, pos1 in bins.getatoms(bin).items():
            for atom2, pos2 in neighatoms.items():
                if (atom1, atom2) in bondpairs or (atom2, atom1) in bondpairs or atom1 == atom2:
                    continue
                elif id2type[atom1] == id2type[atom2]:
                    continue
                rls.append((lambda d: np.sqrt(np.sum(d*d)))(pos1 - pos2))
    x, y = calcgr(rls, cutoff, bin_width, (bins.monocount/2)/(BOX_SIZE**3))
    return x, (y / (bins.monocount))




# ### copoly2 rdf func
# import pair2d
# import readlammps
# def get_rdf(name):
#     rdf_cutoff = 10.0
#     edges = np.arange(0, rdf_cutoff+0.001,0.05)
#     edges_x = (edges[1:]+edges[:-1])/2
#     nlist = readlammps.traj2nlist(next(readlammps.traj(name)), rdf_cutoff)
#     y = pair2d.rpair(nlist)
#     h, _ = np.histogram(y, bins=edges)
#     h *= 2
#     N = len(neigh.data) / 3
#     rho = N / np.prod(neigh.boxsize)
#     V = 4/3*math.pi*(edges[1:]**3 - edges[:-1]**3)
#     h = h/(V*rho*n)
#     return h